正则表达式

字符串是计算机应用中最为广泛的处理对象(html网页,xml,python,....)
并且字符串的定义和组合是多种多样的,比如：
	数字字符串
	email地址字符串
	IP地址字符串
	URL字符串
	....
	
	这些对象都是我们程序设计中需要处理的对象
	计算机要处理这些字符串，首先我们就需要使用某一种语言(规则)去描述你需要处理的字符串对象。
	======>
	专门描述字符串的规则
		正则表达式	
1.正则表达式
	正则表达式是用来描述某一种   规则字符串   的表达式
		*.c  代表一类字符串(所有以.c结尾的字符串)
		find -name *.c 
	脱离了具体语言的一些规则，但是现在大部分的编程语言都实现了或者是支持正则表达式。
		perl
		python
		java
		php
		C/C++
		...
	但是每一种语言实现正则表达式的规则有一些区别(正则表达式的流派)
	
			
2.正则表达式的规则
	利用正则表达式的规则去描述字符串 ---->(模式 pattern)
	如：
		描述一个十进制的数字字符串(模式)
		[0-9]+   ----> 十进制的数字字符串
		
	正则表达式也叫做匹配模式(pattern),他是有一系列特殊含义的字符串组成通常用来匹配和替换文本
	在正则表达式中的字符，分为两种：
		1.普通字符	只代表本身的字符
		2.元字符	有特殊含义(不代表本身)的字符
		
	正则表达式的元字符：
		.  匹配任意单个字符
		[] 字符组 虽然本身由两个字符构成，但是他任然只匹配单个字符
			你要匹配的单个字符都在[]中列举出来了
			如：
			[123] ----> 能够代表 1 或者 2 或者 3
			
			写一个正则表达式表示一个16数字字符：
			[0123456789abcdefABCDEF]
			[] 字符组内部也可以包含元字符 -
			-在字符组内表示连续的ASCII码的字符
			[0123456789abcdefABCDEF]====>[0-9a-fA-F]
			
			描述一个可以做为C语言标识符的字符
			[0-9a-zA-Z_]
		
			[a-zA-Z_]+[0-9]*
			
			
		
		[^] 排除字符串 匹配单个字符,匹配除了[]以内的所有单个字符
			如
				非十进制数字字符
				[^0-9] 匹配一个非数字(0-9以外的字符)字符
		\d  digtial 
			匹配一个十进制数字字符
			\d ===> [0-9]
			
		\D 	匹配一个非十进制数字字符	
			\D ===> [^0-9]
		\w	word
			匹配字母数字和下划线
			\w ===> [0-9a-zA-Z_]
		\W	匹配非 字母数字和下划线
			\W ===>	[^0-9a-zA-Z_]
		\s	匹配空白字符
			\s ===> [\n\t\r\b]
		\S	匹配非空白字符
			\s ===> [^\n\t\r\b]
		
		上面的元字符只能匹配单个字符
		
	匹配多个字符
		+ 匹配一个或者多个先前字符(模式)
			如：
				19+  // 1后面至少有一个9
				-->
				19 199 1999 ....
				
				09+
				09 099 0999 ....
				
				[09]+
				匹配以0和9组合的任意字符串(至少一个字符)
				
				[0-9]+
					[0-9]
					[0-9][0-9]
					.....
				表示所有的十进制数字字符串
				
				
		* 	匹配0个或者多个先前字符(模式)

				09* //0后面可以没有9
				0 09 099 0999 ....
				
				[0-9]*
					空
					[0-9]
					[0-9][0-9]
					.....
				表示所有的十进制数字字符串
		
		? 匹配0个或者1个先前字符(模式)
			19?
			1
			19
			
			[0-9]?
			空
			0
			1
			2
			3
			...
			9

		{数字} 匹配固定数量的先前字符(模式)
			如：
				250{3}
				
				25000
				
				[0-9]{4}
				//固定是有4个数字
				0000
				0001
				0002
				...
				9999
				
		{最小数量,最大数量}
			匹配至少"最小数目"至"最大数目"的先前字符(模式)
			9{0,3}
			空 9 99 999
			
			egrep -nar  [0-9]\{1,4\}
			[0-9]{1,4} //可以是1~4个数字
			0~9999
			

		{最小数量,}
			匹配至少"最小数目"的先前字符(模式)
			9{3,}
			999
			9999
			99999
			...
			
			123{3,}
			12333
			123333
			....
			
	匹配多个子模式
		() 括号中的内容作为一个整体 --->子模式(sub pattern)
			123{1,3}   //模式为单独的 3
				123
				1233
				12333
				
			(123){1,3} //()作为子模式  模式为 123
				123
				123123
				123123123
				
		(|) 两个子模式二选一
			如：
			(abc|123){2}
			
			abcabc
			123123
			abc123
			123abc
			
		要表示元字符本身怎么办？
		转义字符(\后面的那个字符不表示原来的意思了)
		\本身就是一个元字符
		要表示\本身 ===》 \\\\
		====> \.
		\\+  		表示+本身  
		\\.			表示普通的.
		\\*			表示一个普通的 *
		\\\\		表示一个普通的\
		...
		
		练习：
			写一个正则表达式表示一个IP地址
				[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}
			
			写一个正则表达式表示一个小于2^32的十六进制数字字符串
				0[xX][0-9a-fA-F]{1,8}
			
3.标准C语言库对正则表达式的支持
	需求：
		写一个程序,判断一个字符串(母字符串)中是否存在IP字符串(目的字符串)
		
		[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3} 
		//属于字符串的范围
		
NAME
       regcomp, regexec, regerror, regfree - POSIX regex functions

SYNOPSIS
       #include <sys/types.h>
       #include <regex.h>
		
		regcomp用来编译正则表达式
		编译好的正则表达式使用regex_t表示
       int regcomp(regex_t *preg, const char *regex, int cflags);
		把regex指向的原始正则表达式字符串编译为regex_t保存的编译好的正则表达式
		preg：执行一段地址空间,用来保存编译好的正则表达式
		regex：指针,指向原始的待编译的正则表达式
		cflags：编译标志，使用位域实现的
				REG_EXTENDED  使用扩展的正则表达式语法
				REG_ICASE	忽略大小写
				REG_NOSUB	不包含子模式()
			如：
				REG_EXTENDED | REG_ICASE
				使用扩展的正则表达式切忽略大小写
		返回值：
			成功返回0
			失败返回一个错误码，返回的错误码需要使用regerror解析
			
		regexec 用来在string描述的字符串中去匹配正则表达式preg描述的模式
       int regexec(const regex_t *preg, const char *string, size_t nmatch,
                   regmatch_t pmatch[], int eflags);
			preg：指向编译好的需要匹配的正则表达式
			string：原始的待匹配的字符串
			nmatch：正则表达式中描述了多少个模式
					总模式+子模式的个数
					你需要匹配的总共的模式
			pmatch[]：保存匹配到的字符串在母串中的位置
					保存所有匹配到的模式
			eflags：标志是否匹配行首或者行尾,一般为0
			
			返回值：
				成功(已经匹配到了)返回0
					如果母串中有多个匹配，怎么办？
					循环指向此函数
				失败返回一个错误码:REG_NOMATCH
			
char str[1024] = {"abcdefg123.234.11c192.168.3.2xx192.168.3.3ssss"};
#define IP_REG "([0-9]{1,3})\\.([0-9]{1,3})\\.[0-9]{1,3}\\.[0-9]{1,3}"	
		表示了一个总模式(你需要查找的目标模式)
		在你的目标模式中查找固定的字符串
		192.168.3.2  匹配了一个总模式  
		192 第一个子模式
		168	第二个子模式
		查找结果为找到的模式在原始字符串中的位置
		192.168.3.2  匹配了一个总模式  
			[18,29)
		192 第一个子模式
			[18,21)
		168	第二个子模式
			[22,24)
		匹配的结果使用 regmatch_t 来描述，返回的是在母字符串中下标的范围
		The regmatch_t structure which is the type of pmatch is defined in <regex.h>
           typedef struct {
               regoff_t rm_so; //start offset 匹配的下标的起点位置
               regoff_t rm_eo; //end offset 匹配的下标的终点位置
           } regmatch_t;
		
		 regerror 用来把regcomp/regexec 执行的返回的错误码转换成相应的
		 错误字符串的
		 
       size_t regerror(int errcode, const regex_t *preg, char *errbuf,
                       size_t errbuf_size);
			errcode:你要解析的错误码
			preg:编译后的正则表达式
			errbuf：指向一段可用的内存空间，用来保存转换后的错误信息
			errbuf_size:你的可用的空间的大小(防止内存越界(strcpy))
			返回值：
			返回填充到errbuf中错误码的字符串长度
		

		regfree释放preg指向的内存空间的,防止内存泄漏	
       void regfree(regex_t *preg);		
		
		
	







