在copy目录的任务中,经过改进,发现文件的拷贝还是串行的:
	提出一些想法:
		1.主线程中不进行pthread_join,为了回收线程资源,线程函数必须要“分离”
			但是“分离”之后,主线程的结束时间就不好控制了
		2.查找文件的速度(生产者)比复制文件的速度(消费者)快,保证每一个查找到的文件都要正确的被复制
		
		3.既然文件的复制是串行的,为什么还要去开线程呢?
			线程的创建和销毁都是需要时间的。

	在项目中其实有很多类型与这样的问题.
	线程池(解决问题的方案/模式)
	
线程池(Thread_pool)/进程池
	线程池是一种多线程的问题解决方案,处理方法是将“生产者”线程提出的任务添加到任务队列,然后创建一部分线程自动的去完成“任务队列”上面的任务。
	通常情况下,多线程编程都是在需要的时候,创建一个新线程,然后完成指定的任务(函数),完成后退出,一般也能够满足我们的要求。
	但是当我们需要创建大量的线程,并且线程执行一个非常简单的任务后就销毁时候
		大部分的CPU时间都浪费到了线程的创建和销毁上面
		如:
			文件夹COPY
			WEB服务器的响应
			email邮件服务器
			数据库的操作
			....
	我们的程序需要面对大量的请求,同时这些请求执行的任务有非常的简单,占用的时间非常少,程序就有可能处于不停的创建和销毁线程的状态.
	线程池就是解决这一类问题的一个方案(可以降低频繁创建和销毁线程带来的实际开销)
	思路如下:
		一般是采用预创建线程技术,也就是在程序开始的时候创建一定数量的线程.
		线程执行一个固定的“任务分配函数”,当"任务队列"中没有任务的时候,线程自动休眠(等待一个条件),当任务到来的时候,被唤醒,继续执行任务。
		线程完成任务后,不会被销毁,而是自动的去执行任务队列的下一个任务。
		而且,当任务太多的时候,你可以有接口函数去增加线程的数量,当任务少的时候,你可以有接口去销毁部分线程
		创建和销毁线程的时间相对于执行任务的时间可以忽略不计的时候,就没有必要使用线程池
		
		"任务队列"	
		
	线程池的本质是一个结构体描述的数据结构,再提供接口去操作这个线程池(结构体)
	
	//任务结点,可以完整的描述一个任务就可以
	struct task
	{
		//数据域“函数指针+函数的参数”
		void *(*do_task)(void *arg);//函数指针,指向要完成的任务函数(copyfile)
		void *arg;//任务函数的参数
		//指针域
		struct task *next;//指向下一个任务
	};
	//管理结构体
	typedef struct pthread_pool
	{
		//线程互斥锁,保护“任务队列”,避免竞争
		pthread_mutex_t mutex;	
		//线程条件变量,表示“任务队列”是否存在任务
		pthread_cond_t cond;
		//任务队列(链表)
		//产生任务的时候,把任务加入到任务队列,
		//所有的消费者线程都需要从"任务队列"获取任务
		struct task *task_list; //指向任务队列的第一个任务
		
		bool shutdown;//表示线程池是否退出
						//flase 表示不退出
						//true 表示退出
		
		//保存线程池中所有线程的线程ID
		pthread_t *tids;
		
		//线程池中正在服役的线程数量,当前的线程数
		unsigned int active_threads;
		
		//线程池任务队列的最大任务数
		unsigned int max_waiting_task;
		
		//线程池任务队列的当前任务数
		unsigned intcur_waiting_task;
	}Pthread_pool;
	
	
	必须为上面的线程池(结构体)提供的接口:
		init_pool() 初始化一个线程池
		destory_pool()销毁一个线程池
		routine() 每一个线程一开始都会执行的"任务分配函数",自动从任务队列获取任务且执行
		add_task() 往线程池中添加任务
		add_threads() 往线程池中增加活动线程
		remove_threads() 减少线程池中活动线程
		
	pthread_pool.h
	pthread_pool.c	
	
	
线程池API解析:
/*	
	init_pool:初始化一个指定的线程池,线程池中开始有thread_num个线程
	@pool:指针,执行你要初始化的线程池
	@thread_num:指定你要初始化的线程池中开始的线程数量
	返回值:
		成功返回0
		失败返回-1
*/
int init_pool(Pthread_pool *pool,unsigned int thread_num)
{
	//初始化线程池结构体(给结构体中的每一个成员赋值)
	
	//初始化线程互斥锁和条件变量
	
	//循环的创建thread_num个线程,让所有的线程都去执行任务分配函数,并且记录所有的线程ID
}

/*
	routine:任务分配函数,所有的“消费者”线程开始的时候都会执行这个函数,
			次函数会不断的从“线程池”的任务队列中取下任务结点,去执行取下的任务
			任务结点中包含了任务的“函数指针”和“参数”
	arg:表示你的线程池
				
*/
void *routine(void *arg)
{
	//arg表示你的线程池
	
	while()
	{
		//获取线程互斥锁 LOCK
		
		//访问arg表示的线程池,从线程池的任务链表中取下一个“结点”
		if(没有退出 && 没有任务)
		{
			???//睡觉
		}else if(退出(shutdown == true) && 没有任务)
		{
			???//pthread_exit()
		}else //不管有没有退出只要有任务就执行任务
		{
			???//取任务运行
		}
		//释放线程互斥锁 UNLOCK
		
		//执行“结点”表示的任务
		
		//释放结点
	}	
}

/*
add_task:往线程池中添加任务,把指定的任务(函数)和任务参数(函数参数)保存到一个任务结点中,添加到pool指向的线程池的任务队列中
@pool:你要把任务添加到哪一个线程池
@do_task:函数指针,指向你要添加的任务函数
@arg:函数的参数
返回值:
	成功返回0
	失败返回-1
*/
int add_task(Pthread_pool *pool,void *(*do_task)(void *arg),void *arg)
{
	//开辟一个任务结点
	//把第二个参数和第三个参数保存到任务结点中
	
	//加入到pool的任务队列中
	//注意“任务队列”是一个共享资源
	
	//加入后要唤醒等待的线程
}

/*
destory_pool:销毁一个线程池
			销毁前要保证所有的任务都已经完成
			相当于把这个函数做成一个阻塞的函数
@pool:你要销毁的线程池					
*/
int destory_pool(Pthread_pool *pool)
{
	//等待所有任务执行完毕
	//只需要把shutdown置位true
	//唤醒所有线程
	//利用join函数等待所有的线程
	
	//回收所有动态分配的空间
}

//往线程池中增加活动线程
int add_threads(Pthread_pool *pool,unsigned int add_num);

//减少线程池中活动线程
int remove_threads(Pthread_pool *pool,unsigned int remove_num); 









