1.程序
	程序(program)是什么?
	计算机程序一般是指以某些程序设计语言编程,能够运行于某种目标体系架构上的实体。
	
	程序 = 数据结构 + 算法。
	
	数据:用来表示人们思维对象的抽象概念的物理表现叫做数据(把问题中的信息实体化).
		对数据的处理规则叫做指令
	算法:解决问题完整而且准确的描述,是一系列解决问题的清晰的指令的集合。
		计算机程序就是算法和数据的集合(利用算法操作数据)
		
	程序是一个静态的概念(不管运行或者是不运行都存在)。
	程序的一次执行过程叫做一个计算(运行)。

2.程序的执行方式
	(1).顺序执行
		一个程序完全执行完毕后,另一个程序才能被运行
		如:不带操作系统的程序,单片机STM32...
		
		缺点:CPU的利用效率非常低
			a.某些程序在等待外部条件的时候,CPU是空闲的
			
			b.指令运行过程一般可以分为三步:
				取指令------>执行------->回写
				不同的步骤一般由不同的硬件去完成
				
				可以有多个程序同时运行(宏观)。	
				为了提高CPU的利用率,增加吞吐量,引入“并发执行”
			
	(2).并发执行
		多个程序同时运行(宏观),本质上还是顺序执行
		现代操作系统为了让程序并发执行,特地引入了“进程”概念。
		正在进行的程序

3.进程
	进程是具有独立功能的程序,关于某一个数据集合上的一次运行活动
	程序的一次执行过程。
	
	理解为“炒菜(进程)和菜谱(程序)”的关系
	
	
	源程序:
	int main()
	{
		int a,b;
		int sum;
		scanf("%d%d",&a,&b);
		sum = a+b;
		printf("sum =%d\n",sum);
		return 0;
	}
	
	gcc test.c -o test    
	test:程序,静态的概念
	
	./test 
	test的一次计算过程,产生一个进程
	
4.进程和程序的区别
	(1).程序是一个静态的概念(是指令和数据的集合)
		进程是一个动态的概念(动态的产出和动态的消亡)
	
	(2).进程是一个程序的一次执行活动,一个程序可以对应多个进程。
			一个程序可以同时运行几个实例(同时登录两个QQ)
			一个程序内部也可以由多个进程(多进程编程)
			
	(3).进程是一个独立的活动单位,进程是竞争系统资源的基本单位(内存/CPU时间)
	
	OS为什么要引入进程呢?
		就是为了能够让程序并发的运行(同一时间段有多个程序在运行)
		程序的并发实际上就是进程的并发。
		
5.进程状态
	OS把一个进程的执行过程,分为几个不同的阶段(状态):
	就绪态(Ready):进程所有的准备工作都已经完成,只需要CPU去执行进程的指令。
	运行态(Running):CPU正在执行这个进程的指令。
	阻塞态(Blocking)等待(Waiting):进程正在等待其他的外部事件(如:输入)
	
	进程的这些状态可以进程切换

	“就绪队列”:所有处于就绪状态的进程,都处于一个“队列”中。
	
	“调度程序”:负责确定下一个进入“Running”状态的进程
		确定下一个占用CPU的进程
	调度程序根据“调度策略/算法”来确定下一个运行的程序:
		分时系统:调度策略以“时间片轮转”为主要策略的系统
			时间片轮转:分时.每一个进程都执行一段时间(时间片)
			大部分的桌面操作系统,linux/windows/macos/android....
		
		
		实时系统:调度策略以“实时策略”为主要策略的系统
			“实时策略”:每一次调度都取任务队列中优先级最高的那个进程执行,直到这个进程执行完毕或者它主动放弃CPU或者有更高优先级的进程“抢占”
			可能造成低优先级的程序一直处于“饥饿”状态
			如:ucos/freeRTos
			
		可抢占和不可抢占
	
	"僵尸进程(Zombie)"
		当进程退出的时候,父进程没有读取子进程的退出码,子进程就会成为僵尸进程。
		僵尸进程会以终止状态保存在进程表中,一直等待父进程读取退出状态码且回收资源。
		一个进程结束了,但是它的父进程没有等待(wait/waitpid)它,它就会成为僵尸进程
		
		危害:
			占用系统资源
	
	"孤儿进程"
		父进程结束了,子进程就被称为“孤儿进程”
		孤儿进程会被祖先进程收养
		

6.linux进程地址空间的布局
	程序运行的第一件事,就是申请一块内存区域来存储程序的“数据(数据/指令)”,不同的数据的属性是不一样的
	“分区域”来存储程序的数据(分段,分为不同的逻辑区域存储不同属性的数据)
	不同属性的数据,存储到不同的“内存段”中,不同的内存段的属性以及管理方法不同

	.text  指令段,主要存放指令
		只读并且共享,这段内存在程序运行期间内不会被释放
		随进程的持续性
		
	.data	数据段
		主要存放程序已经初始化的全局变量和已经初始化的静态(static)变量
		可读可写,这段内存在程序的运行期间不会被释放,随进程的持续性
		
	.bss	数据段
		主要存放程序未初始化的全局变量和未初始化的静态(static)变量
		可读可写,这段内存在程序的运行期间不会被释放,随进程的持续性
		.bss段,在程序初始化的时候,可能全部被初始化为0
	
	.rodata readonly data 只读数据段
		主要存放程序中的只读数据(字符串,常量..)
		只读,这段内存在程序的运行期间不会被释放,随进程的持续性
	
	.栈空间(stack)
		主要存放局部变量
		可读可写,这段内存在程序的运行期间会被自动释放(定义在哪一个{}内部,在大括号结束后,变量就自动被释放),随代码块的持续性。
		返回一个局部变量的地址就有问题

	.堆空间(heap) 
		主要是malloc/realloc/colloc动态分配的空间
		可读可写,这段内存在程序的运行期间不会自动释放,随进程的持续性
		一旦分配就一直存在,直到你手动free或者程序结束
		
7.linux下面关于进程的API函数解析
	1.创建一个进程
	fork()是用来创建一个新进程的,你要使用fork创建一个新进程,首先你要知道一个进程中包含什么东西?
		数据(系统数据和用户数据)和指令
	所有你创建一个新进程,也需要数据和指令,来自哪里呢?
	来源于父进程(调用fork函数的进程叫做父进程,新创建的进程称之为子进程),子进程的一切(数据和指令)都来自于父进程
	
	fork这个函数在创建子进程的时候,copy了父进程的一切
		copy了父进程的数据和指令
		父进程的变量,数据对象
		文件描述符
		文件偏移量
		标准IO缓冲区的内容
		.....
		
	fork成功后,就会有两个一模一样的进程在执行一模一样的代码
	既然两个进程是一模一样的,如何区分父进程和子进程呢?
	
	通过返回值区分.fork函数一次调用,有两次返回,在fork函数内部实现的
	如果fork成功,就会有两个进程在执行当前的代码,为了区分父进程和子进程,fork一次调用,有两次返回,一次是父进程的返回,一次是子进程的返回。
	
	fork的伪代码可能是这样实现的:
	fork
	{
		....
		clone()
		....
		//下面的代码就有两个进程在执行
		if(是父进程)
		{
			return 子进程的pid;
		}else if(是子进程)
		{
			return 0;
		}else
		{
			return -1;
		}
	}
	linux系统为了区分每一个进程,会为每一个进程分配一个唯一的ID(PID),使用pid_t(unsigned long)表示
	
	NAME
		   fork - create a child process
		   创建一个子进程
	SYNOPSIS
		   #include <sys/types.h>
		   #include <unistd.h>
		   pid_t fork(void);
			返回值:
				如果失败返回-1,同时errno被设置
				如果成功,子进程和父进程都会返回(同一段代码有两个进程在执行)
				父进程返回子进程的PID
				子进程返回0
	fork之后,操作系统会copy出一个与父进程完全相同的子进程,这两个进程共享代码段的空间,但是数据段相互独立(copy-on-write),子进程的数据都是从父进程的地址空间中copy过来的,指令指针(PC)也相同(父进程执行带哪里来了,子进程也执行到哪里来了)
	
	问题:
	fork后面的语句,有两个进程正在运行,那么谁先执行呢?(单CPU)
		这个是不确定的,取决于调度算法。		
	
	linux系统为了区分每一个进程,会为每一个进程分配一个唯一的ID(PID),使用pid_t(unsigned long)表示,同时还提供了两个配套的API函数,用来获取PID和PPID
	
	SYNOPSIS
       #include <sys/types.h>
       #include <unistd.h>

       pid_t getpid(void);  //返回调用者的id
       pid_t getppid(void); //返回调用者的父进程id
	   
	2.进程退出
	
	3.等待子进程退出
	
	4.exe函数族
	
	
	



		
		


作业:
	1.了解进程地址空间的布局
	2.简单了解一下“虚拟内存”
	3.copy-on-write是什么东西?
	4.什么是前台进程和后台进程,如何转换?
	5.并行和并发的区别?
	6.了解一下进程间通信?


		
		







