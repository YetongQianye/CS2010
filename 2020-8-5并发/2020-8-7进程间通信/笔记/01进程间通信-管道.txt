进程间通信(IPC)
IPC:internal process communication

实质:信息(数据)的交换

有人就说,这个还不简单吗?
	我在一个进程里面定义一个全局变量a,然后再给a赋值一些有特殊含义的值,然后再让另一个进程去读取这个a的值,不就可以了嘛?
	这种方法,可以吗?
	肯定是不可以,因为进程的地址空间是独立的。
	所有,两个进程要通信,必须把数据放到大家都可以访问到的一个地方
	
	文件(一个文件可以被多个进程同时打开,也是最早期的进程间通信)
		文件在文件系统中,大家都可以访问
		但是这种方式,有一个缺点:通信的速度太满了
		
	======>
	一般的改进方式:在操作系统内核中开辟一段空间(某一种机制,提供具体的API),进程再去访问
	
	IPC的方式:
		管道
			pipe 无名管道
			fifo 有名管道
		信号
		消息队列	SystemV消息队列/Posix消息队列
		共享内存	SystemV共享内存/Posix共享内存
		信号量		SystemV信号量/Posix信号量
		socket通信(unix域协议)
		
1.管道
	很久很久以前,进程间通信的方式都是通过文件,
	这种方式,有一个缺点:
		它的效率太低了
	但是这种方式,也有一个非常大的好处:
		简单,不需要提高额外的API函数接口(直接利用文件系统的API函数)
		
	有人就想,能不能改进一下?
		问题在哪里呢?文件的内容在外设,在文件系统中,造成访问的效率低
		能不能把文件的内容放到内核或者内存上面去呢?
		管道就是把内容放到内核中,又可以利用文件系统的API函数
		
	(1).无名管道 pipe
		在文件系统中没有名字(没有inode),它的内容在内核中,访问pipe的方式是通过文件系统的API(read/write)
		
		一般访问文件的方式:
			fd = open(文件名);
			read(fd,,,);
			write(fd,,,,);
			....
		它没有名字,它不能使用open函数打开,但是read/write有需要一个文件描述符
		所有在创建这个pipe的时候,就必须要返回“文件描述符”
		pipe在创建的时候,在内核中开辟一块缓冲区,作为pipe内容的存储空间,同时返回两个文件描述符(一端用来读,一端用来写)
		并且有如下特定:
			a.有两端,一端用来读,一端用来写
			b.内容读走了就没有了(不存在于pipe中)
			c.按顺序读,不支持lseek
			d.pipe(无名管道)随内核的持续性
			
			
	函数接口:
		NAME
			   pipe, pipe2 - create pipe  创建一个管道
		SYNOPSIS
			   #include <unistd.h>
			   pipe是用来创建一个无名管道,pipefd指向一块空间,用来保存创建好的无名管道的两个文件描述符,pipe创建的管道,默认是阻塞模式。
				int pipe(int pipefd[2]);
				pipefd:指向一个数组的指针,保存两个文件描述符
					pipefd[0]保存读的文件描述符
					pipefd[1]保存写的文件描述符
				返回值:
					成功返回0,
					失败返回-1,同时errno被设置		
	思考:			
	pipe是不是任意两个进程都可以通信呢?
		不是(两个进程需要获取同一个管道的文件描述符)
	一般只能用于父子进程通信(有亲缘关系,且继承了文件描述符即可).		
		
	pipe是单向数据通道(半双工),
	pipe本身的全双工的,但是两个进程使用一个管道实现全双工通信,就必须以某一种方式去同步,不然自己很容易读取到自己发送的数据,一般做成两个或者多个管道,一个用来读,一个用来写。
		
		
		
		
		
		
		
		
	
		
	










