1.gcc的编译步骤
	预处理:处理以#开头的行
		1.头文件展开
		2.宏定义替换
		3.条件编译
			#if 0
			
			#endif
			
			#ifdef
			
			#endif
			....
			
		(arm-linux-)gcc -E 1.c -o 1.i	
		不会进行错误检测
	编译
		把程序文件变成相应平台的汇编文件
		
		(arm-linux-)gcc -S 1.i -o 1.S
		gcc--->x86汇编 CISC
		arm-linux-gcc --->ARM汇编  SISC
		进行错误检测
		汇编语言还是一种高级语言,机器还不能识别
		
	汇编
		把汇编语言转换成二进制语言(机器指令)
		(arm-linux-)gcc -c 1.S -o 1.o
		1.txt
		1.i
		1.S 
			都是无格式文件“文本文件”
		1.o是有格式文件
	
	链接
		(arm-linux-)gcc 1.o -o 1
		把多个.o文件以及库文件链接成可执行文件

	
GDB调试工具的使用
	可以让代码单步运行,设置断点,并且可以打印出相应的变量的值,用来调试core文件(核心文件)
	我们可以把我们的程序运行到GDB这个环境上
	
	1.在编译我们的代码的时候,要加入调试信息,
		gcc 1.c -o 1 可执行文件1中,不包含任何的调试信息,不能在gdb这个环境上面运行
		gcc -g 1.c -o 1 可执行文件1中,包含调试信息,能在gdb这个环境上面运行
		
	2.运行
		gdb + 你要调试的文件
		进入了GDB的调试环境
		常用的命令有如下一些:
			b		breakpoint   设置断点
				breakpoint:断点,gdb运行到断点的时候会停下来
						断点可以是函数名/行号
						b main 程序运行到main函数的时候会停下来
						b 18 程序运行到18行的时候会停下来
						b sum 程序运行到sum函数的时候会停下来
				info b 查看所有断点的信息
				
			r run 程序开始运行,运行到断点处会停下来

			p n --->print  n  打印变量n的值

			n next  下一步,单步运行,执行下一行代码
			
			s step into  单步运行,执行下一行代码
				n和s的区别?
				仅仅在执行函数调用指令的时候有区别
				n会把函数调用指令当成一条语句,一次性执行完毕
				s会进入到函数内部一步一步去运行
			l list 列举出源代码
			
			disassemble  反汇编
			
			--help  帮助
			quit 退出调试
				
		写一个简单的代码,使用GDB调试一下。
			设置断点(产生段错误的函数)
			n ......
			p 变量
			
	
	
	
	
	
	
	
	
	
	



















