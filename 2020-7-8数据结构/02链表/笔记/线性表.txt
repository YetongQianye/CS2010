线性表
数据元素之间的关系是线性的。
1.线性表的定义
	线性表中的数据元素可以是各种各样的,但是同一个线性表中的数据元素必定具有相同的属性,即属于同一个数据类型,而且相邻的两个元素之间存在着序偶关系。
	若将线性表记为:
	(a1,a2,a3,a4,a5....an)
	(1).存在着唯一一个被称为“第一个”的数据元素
	(2).存在着唯一一个被称为“最后一个”的数据元素
	(3).除了第一个以外,集合中的每一个元素均有且仅有一个前驱元素(上一个)	
	(4).除了最后一个以外,集合中的每一个元素均有且仅有一个后继元素(下一个)
	
	
2.线性表的实现
	要存储线性表,必须要存储两类东西:
		"数据"   “逻辑关系(结构)”
	在存储线性表的时候，有两种方式:
	(1).顺序结构
		使用存储单元的物理关系去描述他们的逻辑关系,逻辑关系在前面的元素,物理关系也在前面
		
		指的是使用一组地址连续的存储单元依次存储线性表中的每一个数据元素---->"数组"
		(1 3 5 7 9 2 4 6 8 10)
		按照升序存储上面的元素
		int a[10];
			a[0]  1
			a[1]  2
			a[2]  3
			....
			a[9]  10
		各个元素的物理结构的先后顺序,就可以表示它们的“逻辑关系”
		
		顺序结构优点:
			简单,查找方便(利用下标遍历)
		缺点:
			删除元素和插入元素不方便,要挪动太多的元素
			
	有人就提出,逻辑关系一定需要物理关系去描述吗?
		不需要,每一个元素在物理上的哪一个位置,并不重要,只需要能够正确的描述数据元素之间的逻辑关系即可。
		
		存储一个数据元素的时候,再额外的开辟一个空间,来保存当前元素的下一个元素或者上一个元素的地址
		
	(2).链式线性表--->链表
		在存储线性表的时候，不需要使用连续的地址存放,可以随意的在内存的任意一个位置存储数据元素,只不过需要存储当前元素的下一个元素或者上一个元素的地址
		
		如何实现?
		存储一个数据元素的时候还需要存储一个地址
		
		原来的数据元素和地址并不一定是同一个类型,但是原来数据元素和地址又是需要构成一个新的数据元素----->struct 
		
		typedef  已有的数据类型   新类型名
		typedef  int Elemtype; //Elemtype就相当于int
		Elemtype;//假设原来的数据元素类型
		struct node //用来存储当个的数据元素和它本身的上一个或者下一个地址
		{
			Elemtype data;//数据域,存储用户数据
			struct node *next; //指针域,存储元素之间的关系
		};
		
		链式线性表:
		
		单链表
		带头节点单链表
		带头节点双向链表
		循环链表

		#define DElemtype  int *   //仅仅在预处理的时候替换
		typedef int *  TElemtype;  	//TElemtype是原有类型的别名,表示int *
		
		DElemtype a,b;  //  int *a,b;
		TElemtype c,d;  //int *a,int *b;
		a,b,c,d分别是什么类型？
		a --->int *
		b --->int
		c --->int *
		d --->int *
		
		
		编译的四个步骤:
		预处理  处理以#开头的行
				头文件
				宏定义
				条件编译
				..
		编译	把C语言变成对应平台的汇编语言
		汇编	把汇编语言编程二进制语言
		链接	把多个目标文件链接成可执行文件
		
		
	创建一个链表:
		//为用户数据开辟一个存储空间(堆malloc)
		
		//把结点插入到链表
			尾插法
				按照用户输入的顺序建立链表
			头插法
				按照用户输入逆序建立链表
			建立升序链表
				把结点P插入到first指向的有序链表中去,使插入后的链表任然有序
	实现的操作:
		增,删,改,查
	
	段错误 segemention fault
	产生段错误的原因:
		指针或者内存的非法访问
		访问空指针
		struct node *p = NULL;
			p->data = d; //从NULL这个地址去访问第data这个成员,对内存的非法访问
			p = p->next;
		
		访问野指针
		struct node *p;//野指针
			p->data = d;
			//有可能段错误.p没有初始化,p指向一个未知的区域,这个区域是否可以访问,不确定,如果不能访问则段错误。
			
			解决访问,加打印信息:
			
			printf("xxxxxxx\n");
			struct node *p = NULL;
			p->data = d; //从NULL这个地址去访问第data这个成员,对内存的非法访问
			printf("ooooooo\n");
			
			上面只会打印xxxxx而不会打印oooooo
			系统中定义了两个宏:
			__FUNCTION__ 代表当前所在函数的“函数名”,字符串
			__LINE__ 代表当前所在的“行号”,整数
			printf("%s:%d\n",__FUNCTION__,__LINE__);
			



	
	
作业:
	所有作业的结点类型如下:
	typedef int Elemtype;//用户数据元素类型
	struct node 
	{
		Elemtype data;//数据域
		struct node *next;//指针域,用于保存下一个结点的地址
	}; 	

	1.写一个函数反序输出单链表各个结点的值(不能改变原链表的内容和结构)
		如:链表为 1 3 5 7 9 
		输出为:9 7 5 3 1
	
	void print_reverse_list(struct node *list)
	{
		//把所有的结点遍历一遍,把值存储到一个数组中
		
		//逆序打印数组
	
	}
	
	2.单链表就地逆置(不能申请新的空间,利用原有结点的空间)
		如链表为 1 3 5 7 9 
		逆置后的链表为:9 7 5 3 1
	struct node *reverse_list(struct node *list)	
	{
	
	
	}
		
	3.建立一个链表逆序存储一个整数的各个位上的数字
		如输入:132
		建立链表:2-->3--->1
		
	struct node *create_list_by_num(char *num)	
	{
	
	
	}	
		
	4.使用链表逆序存储两个整数,实现两个超大数的加法,把结果链表返回
		
	struct node *add_two_numbers(struct node *la,struct node *lb)	
	{
	
	
	}		
		
	数据结构/	
		链表/
			linklist/
			homework/
		栈和队列/
			
		二叉树/
		
		图/
		
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	