图论
图是研究数据元素之间多对多的关系,在这种结构中,任意两个元素之间都有可能存在关系。

1.图的定义
	图是一种非线性数据结构,形式化描述为:
		Graph=(V,R);  数据元素+关系
	其中,V = {vi|vi属于图的数据类型,i=0,1,2,3...n-1};V是图中顶点(Vertex)元素的集合,n=0时,V为空集
	R是图中顶点关系的集合,R={<Vi,Vj> | Vi,Vj属于V,且p(Vi,Vj)存在,P表示路径(关系)};
	P(Vi,Vj)为顶点Vi,Vj之间是否存在路径的判断条件,即如果Vi,Vj之间的路径存在,则:
		P(Vi,Vj)为真,且<Vi,Vj>属于R
		
	有向图:图中顶点的路径(关系)是有方向的。
		如果关系<Vi,Vj>属于R,但是<Vj,Vi>不一定属于R
		有向图中的路径称为“弧”
		
	无向图:
		如果关系<Vi,Vj>属于R,则<Vj,Vi>一定属于R
		如果Vi到Vj存在路径,则Vj到Vi也一定有路径
		无向图中的路径称为“边”
		
		
	网:如果在图的关系<Vi,Vj>上附加一个权值w
			w
		Vi---->Vj
		称w为弧或者边的权,带权的图称为网,权值w的具体含义,视图在不同的应用领域而定,
		如果顶点表示城市,权w可以表示两个城市之间的距离...
		
	顶点的度:
		顶点的边或者弧的条数
		“出度”/"入度"

	路径:
		直接路径
		间接路径

2.图的存储
	“数组表示法(邻接矩阵)” <-----
	“邻接表” <------
	“十字链表” <------
	“邻接多重表”

	2.1 数组表示法(邻接矩阵)
		G = (V,R);保存一个图至少需要保存顶点还需要保存关系
		可以使用两个数组来存储图G
		一个一维数组存储G中的顶点集合V。另一个二维数组存储G中的顶点关系R,这个二维数组就是我们所说的邻接矩阵。
		
		实现方法:
		typedef int VType;//假设顶点的数据类型为int
		typedef int AdjType;//边的类型(权)
		#define MAXN 1024
		typedef struct graph
		{
			
			VType V[MAXN];//一个一维数组表示图中顶点的集合
			AdjType A[MAXN][MAXN];//二维数组表示图中顶点关系的集合 "邻接矩阵"
								//A[i][j] = w;//在二维数组中有一个关系,权值为w
								V[i]--->V[j]有关系,且权为w
								i,和j都是下标,i是起点在V数组的下标,j是终点在V数组的下标
								A[i]行记录的是i这个顶点所有出去的关系
								
			int vexnum;//图中顶点的个数
			int arcnum;//图中边的条数
		}Graph;	

		Graph g; //定义了一个图g
		Graph *g = malloc(sizeof(Graph));//动态开辟了一个图,并且使g指向它



	2.2 邻接表(使用链表存储关系集合)
		邻接表(Adjacency List)是将图中每一个顶点V和由V发出的边构成单链表
		邻接表是图的一种链式存储方式
		
		顶点使用数组表示
		
		typedef char VType;//假设顶点的数据类型为char
		typedef int AdjType;//边的类型(权)
		
		//图是由很多顶点和顶点发出的关系组成
		//每一个顶点V和由V发出的边(关系)构成单链表
		
		//边的类型
		struct Bian
		{	
			int stop_index;//这一条边的终点在顶点数组的下标
			AdjType w;//这一条边权
			struct Bian *next;//下一条边 
		};		
		
		//顶点
		struct Vertex
		{
			VType data; //顶点数据
			//此顶点的所有关系构成的单链表
			Bian *first; //此顶点的第一条边
		};

		图:
		struct Vertex[MAXN];//表示图

3.图的两种遍历方式
	图的遍历是树的遍历的推广,也是按照某一种规则访问图中的每一个顶点一次且仅一次的操作
	也是将网状结构线性化的过程.
	对图的遍历通常可以使用两种思想
		深度优先搜索算法
		广度优先搜索算法
		
	3.1 深度优先搜索算法(DFS:Depth First Search)	
		类型于树的先序遍历。
		
		假设初始时,图中的各顶点均未被访问,从图中指定的顶点(V0)出发,访问V0,然后搜索V0的第一个邻接点(只能通过邻接表/邻接矩阵确定)Vi,如果Vi未被访问,则访问它,再搜索Vi的第一个邻接点(深度优先).....
		如果某一个顶点的邻接点全部被访问完毕,则回溯到它的上一个顶点,再从此顶点开始以深度优先的方法搜索下去.....
		直到能访问的所有顶点全部访问完毕为止。
			
		实现方法:
			需要使用一个外部数组来标记相应的顶点是否被访问(顶点仅被访问一次)
			int visited[MAXN] = {0};
				visited[i] = 1;//顶点数组中下标为i的顶点已经被访问过了
				
				
			DFS(v)  以深度优先搜索的思想访问v以及v的邻接点,以及邻接点的邻接点...
			{
				//访问v本身并且标记v表示的顶点已经被访问
				print(v)
				visited[v]=1;
				//访问v的第一个(未被访问的)邻接点v1,访问方法同样是按照DFS的方式去访问
				if(visited[v1]==0)
				{
					DFS(v1);
				}
				//再以深度优先的方法访问v的第二个(未被访问的)邻接点
				if(visited[v2]==0)
				{
					DFS(v2);
				}
				.....
				//以深度优先搜索的思想访问v的最后一个邻接点
				if(visited[vn]==0)
				{
					DFS(vn);
				}
				
				====>
				for(vi=取v的第一个邻接点;vi存在;vi=取v相对于vi下一个邻接点)
				{
					if(visited[vi]==0)
					{
						DFS(vi);
					}
				}
			}
		
		======>
			void DFS(v)
			{
				//访问v本身并且标记v表示的顶点已经被访问
				print(v)
				visited[v]=1;
				for(vi=取v的第一个邻接点;vi存在;vi=取v相对于vi下一个邻接点)
				{
					if(visited[vi]==0)
					{
						DFS(vi);
					}
				}
			}
		
			取v的第一个邻接点?
			对于邻接矩阵:
				g->A[v][]这一行中第一个不为VERY_BIG的那个顶点
				
			//获取图g中下标为v的那个顶点的第一个邻接点下标
			//如果没找到返回-1
			int get_first_adj(g,v)
			{
				//遍历关系数组的下标为v的那一行
				int i=0;
				for(i=0;i<g->vexnum;i++)
				{
					if(g->A[v][i] != VERY_BIG)
					{
						return i;
					}
				}
				return -1;//表示没有邻接点
			}
			
			
			取v相对于vi下一个邻接点?
			int get_next_adj(g,v,vi)
			{
				//遍历关系数组的下标为v的那一行从vi开始的数
				int i;
				for(i=vi+1;i<g->vexnum;i++)
				{
					if(g->A[v][i] != VERY_BIG)
					{
						return i;
					}
				}
				return -1;//表示没有邻接点
			}
		
		DFS(v)其实并不能访问图中的每一个顶点,因为有些顶点可能是v到达(直接/间接)不了的
		
		
		void DFStravel(g)
		{
			//初始化标记数组
			int i;
			for(i=0;i<g->vexnum;i++) //遍历顶点数组
			{
				if(i为下标的顶点未被访问)
				{
					DFS(g,i);
				}
			}
		}
		
	3.2 广度优先搜索算法(BFS:Breadth First Search)
		类似于树的层次遍历
		
		初始时,假设图中的所有顶点均未被访问,从图中某一个顶点(v0)出发,访问v0,并且依次访问v0的各个邻接点,然后分别从这些被访问过的顶点出发,任然按照广度优先搜索的策略访问其他顶点.....直到能访问的顶点全部被访问为止。
		
		DFS: 你--->你的长子---->长子的长子.....
		BFS：你--->大儿子,二儿子...(儿子们)
					-->大儿子的儿子们
					-->二儿子的儿子们
					....
		
		假设从v0开始:
			v0
			访问v0,并且标记已经被访问
				访问v0的第一个邻接点v1(访问且标记)
				访问v0的第二个邻接点v2(访问且标记)
				...
				直到v0的所有的邻接点都被访问
		
			按顺序访问这些已经被访问过的邻接点的邻接点(必须记录访问过的邻接点的顺序)
				v1
					访问v1的第一个邻接点v1_1
					访问v1的第二个邻接点v1_2
					....
					直到v1的所有的邻接点都被访问
				v2
					访问v2的第一个邻接点v2_1
					访问v2的第二个邻接点v2_2
					....
					直到v2的所有的邻接点都被访问
				
				...
				直到队列为空。
		
		假设从下标为v0开始的邻接点开始访问:
			//初始化标记数组
			
			//初始化一个队列
			
			for(v0;v0<g->vexnum;v0++)
			{
				if(v0未被访问)
				{
					//访问v0并且标记v0已经被访问
					
					//v0入队列
					while(队列不为空)
					{
						出队
						
						访问出队元素的所有邻接点,且在访问的时候入队列
					
					}
					//可以把所有从v0开始可以访问到的顶点全部访问完毕
				}
			}
			
4.最短路径算法
	解决带权有向图中两个顶点最短路径的问题
	最短路径算法主要有两个:
		Dijkstra(迪杰斯特拉)算法 <--------
		Floyd(弗洛伊德)算法
	
	迪杰斯特拉算法解决从网络中任意一个顶点(起点)出发,求它到其他各顶点(终点)的最短路径问题

	Dijkstra(迪杰斯特拉)算法需要三个辅助向量(数组):
	
	(1).向量S[n] <----标记向量
			表示顶点v0到其他任何一个顶点(vi)的最短路径是否已经求出
	
			s[i] == 0 表示从起点v0到终点vi的最短路径暂时还没有确定
			s[i] == 1 表示从起点v0到终点vi的最短路径已经确定
			初始化
			S[n] = {0};
	(2).向量dist[n] <-----保存起点到其他顶点的最短路径值		
			dist[i] 保存的是顶点v0到vi的最短路径长度(不一定是最终的最短路径)
			
			初始化时:
				dist[i] = g->A[v0][i]
					dist[i] = <v0,vi>上的权值w,
					if(P<v0,vi>)存在 存在直接路径  dist[i] = g->A[v0][i]  (w)
					if(P<v0,vi>)不存在 不存在直接路径  dist[i] = g->A[v0][i](VERY_BIG)

	(3).向量path[n][n]  
		path[i]这一行保存v0到vi最短路径上所有顶点
		
		算法思路:
		目的就是把v0到其他所有顶点的最短距离都确定下来
			n个顶点,最终需要求出n-1条最短路径
				V0-->V1
				V0-->V2
				...
				V0-->Vi
				...
				V0-->Vn-1
				
		step1:
			显然,从源点V0到其他各顶点中的确定的第一条最短路径的长度为dist数组中最小的那一个dist[u]
				dist[u] = min{dist[w]|w=0,1,2,3,..n-1且s[w]==0};
				在没有求出最短路径的各顶点中取距离最小的那一个,作为当前确定的最短路径
				
				原因?
					dist[u]是dist数组中未确定的最小的值,
					不可能存在 dist[v0-->u] > dist[v0--->x] + dist[x--->u]
				
		step2:
			根据当前确定的最短路径u,更新其他没有确定的最短路径 
			s[w] == 0表示v0--->w的最短路径未确定
			if(dist[w] > dist[u] + dist[u,w])
				dist[w] = dist[u] + dist[u,w]
				
		回到第一步确定一条当前最短路径

	伪代码:
	//求图g中,顶点v0到顶点vp的最短路径
	AdjType dijkstra(Graph *g,int v0,int vp);
	
	//求图g中,顶点v0到其他各顶点的最短路径
	void dijkstra(Graph *g,int v0)
	{
		//定义并且初始化三个辅助向量
		
		//向量S[n] <----标记向量
		
		//向量dist[n] <-----保存起点到其他顶点的最短路径值
		//初始时为g->A[v]那一行
		
		//向量path[n][n]  <-----path[i]这一行保存v0到vi最短路径上所有顶点
		//路径第一个顶点肯定是源点 path[i][0] = g->V[v0]
		//如果<v0,vi>有直接路径
		//已知路径为v0-->vi,第二个点应该是终点,path[i][1] = g->V[vi]
		
		
		//一条一条的确定最短路径
		//有n个元素,总共有n-1条最短路径(假设到本身的最短路径已经确定)
		//每一次循环都会确定一条最短路径
		for(i=0;i<g->vexnum-1;i++)
		{
			//step1:从没有确定的最短路径数组中找出最短的一个,作为当前确定的最短路径
			//s[u] == 0 && dist[u] 是dist数组中最小的
			
			
			//标记v0--->u的最短路径已经确定
			
			
			//step2:根据当前确定的最短路径u,更新其他没有确定的最短路径
			//if(dist[w] > dist[u] + dist[u,w] && s[w] == 0)
			//	dist[w] = dist[u] + dist[u,w]
			
			for() //遍历没有确定的最短路径
			{
				if() //根据条件更新最短路径已经path
				{
					
				
				}
			}
		}
		//v0到所有顶点的最短路径都确定了
		//dist数组保存的是最终的最短路径
		//path数组保存的是最短路径经过的顶点序列
		
	}
	
	




			

