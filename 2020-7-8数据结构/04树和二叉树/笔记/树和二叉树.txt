树(tree)和二叉树
	到现在位置,我们一直讨论的数据结构都是“线性结构(单链表,带头节点单链表,栈,队列)”,其中的每一个元素(除了第一个和最后一个)都只有一个前驱和一个后继。
	但是在实际应用中,发现“线性结构”有时候并不能满足我们的要求,必然存在某些时候需要使用“非线性结构”,其中最典型的就是-----树
	
	元素和元素之间的关系不再是一前一后,而是一前多后
	
1.树
	树(Tree)是由n(n>=0)个结点的有限集,在任意一颗非空树中
	(1).有且只有一个特定的结点被称为根(root)节点
	(2).当n>1的时候,其余的结点可以分为m个互不相交的有限集(T1,T2....Tm)
		其中每一个集合本身又是一颗树,称为根的子树(SubTree)
	
	实现的时候:
		树的结点一般包含一个数据元素(用户数据)以及若干个指向子树的分支(关系)
		数据结构 = 数据 + 关系
							物理关系表示逻辑关系
							直接记录逻辑关系(链式)

	结点的度:结点拥有的子树数(分支数)称为结点的度,度为0的结点称为叶子结点或者终端结点,度不为0的结点称为非终端结点或者分支结点
	
	结点的层次(Level):从根结点开始定义,根为第一层,根的孩子为第二层,....
	树的结点中最大的层次称为树的深度(Depth)或者高度(Height)
	
	在使用树的时候,一般只会研究树中一个非常小的分支---->二叉树
	
2.二叉树
	二叉树(Binary Tree)是树中的一种,它的特点是每一个结点至多只有两颗子树(树中不存在度大于2的结点),并且,为了区分两个子节点,子树有左右之分,顺序不能颠倒
	
	二叉树有五种常见的形态:
		空树
		只有一个结点
		只有一个左子结点
		只有一个右子结点
		儿女双全
		
	常见的两种二叉树:
		满二叉树:
			一颗深度为k且具有2^k-1个结点的二叉树为满二叉树。
			“在不增加数的层次的情况下,不能向二叉树中添加新结点了”
			
		完全二叉树:满足下面的条件的二叉树
			a.除了最后一层,为一颗满二叉树
			b.最后一层的结点,从左至右排列,没有空洞
			满二叉树绝对是完全二叉树。
		
	二叉树的性质:
		1.在二叉树的第i层上至多有2^(i-1)个结点(i>=1)
			数学归纳法
			a.当i=1时,结论明显成立
			b.证明k=i时候,i+1结论成立即可
				第i层的时候结点个数为2^(i-1)
				第i+1层明显最多有
				2^(i-1)*2
				2^(i)
				当k=i+1的时候,结论也成立
					
		2.深度为k的二叉树至多有2^k-1个结点(k>=1)
			满二叉树的结点个数

		3.对任意一颗二叉树T,如果终端结点数量为n0,度为2的结点数量为n2,则有
			n0 = n2+1
			
			设
				二叉树中度为0的结点为n0
				二叉树中度为1的结点为n1
				二叉树中度为2的结点为n2
				总结点数量:N = n0+n1+n2   (1)

			设树的分支数量为B,则有:
					B = 0*n0+1*n1+2*n2  (从上往下看)
					B = n1+2*n2  			(2)
				从下往上看:一个结点只对应一个父结点(除了root),
					任何一个结点都对应一个向上的分支
					B = N-1;				(3)
					
					n0-1 =n2
				
		4.如果给具有n个结点的完全二叉树的每一个结点编号,从上至下,从左至右
			可以从这个编号,得出结点之间的编号的关系:
				编号为i的结点,它的左子结点编号为2i
							  它的右子结点编号为2i+1
							  它的父结点编号为i/2
		
			证明:
				设编号为i的结点的层次为k,该层的第一个结点编号为:2^(k-1)
					因为该层上面有k-1层,有2^(k-1)-1个结点,所有第k层的第一个结点为2^(k-1)
					k+1层(i的孩子那一层)的第一个结点的编号:2^k
					
					编号为i的结点,在所在的一层前面有i-2^(k-1)结点,假设y为i的左子结点
					y的前面肯定有(i-2^(k-1))*2个结点(因为i前面每一个结点都有两个子节点)
					y的编号为:(那一层第一个结点的编号+y到第一个结点的距离)
						y = 2^k + (i-2^(k-1))*2
						  = 2^k + 2i -2^k
						  = 2i
					证明了i的左子结点的编号为2i,右子结点为2i+1 
						  
3.如何存储一颗二叉树
	数据结构 = 数据 + 关系
			物理关系表示逻辑关系(顺序结构)
			直接记录逻辑关系(链式结构)
	存储一颗二叉树需要存储什么?
		结点本身的用户数据
		结点与结点之间的关系(要知道当前结点的父节点是谁,知道当前结点的子节点是谁)
		
		(1)使用顺序存储结构
			物理关系表示逻辑关系(顺序结构)
			用一组地址连续的空间来存储二叉树上从左至右从上至下的每一个结点
			数组下标为1的位置保存根结点......
			
			利用完全二叉树的性质:
				编号为i的结点,附近的编号为i/2,左子结点编号为2i...
			数组的下标表示结点的编号。
			不仅存储了数据,还存储了关系
			
			对于任意一个结点,下标为q,它的父节点应该存储于下标为q/2的位置,它的左子结点应该存储与下标为2q的位置.....
			
			typedef int ElemType;//树中的用户数据类型
			#define MAX_TREE_NODE 1024
			ElemType SqBiTree[MAX_TREE_NODE];
			
			SqBiTree[1] 保存根节点
				第i个结点
					SqBiTree[i] 它的左子结点保存在SqBiTree[2i]
								它的右子结点保存在SqBiTree[2i+1]
								它的父结点保存在SqBiTree[i/2]
			
			顺序存储二叉树有一个限制,只能保存“完全二叉树”
			但是很多二叉树不是完全二叉树。
			为了维持二叉树的关系,把一颗普通的二叉树,当成是一颗“完全二叉树”
			=====>"浪费空间"
			
			
			
		(2).链式存储一颗二叉树
			用一组地址不连续的空间去存储每一个结点,关系使用“指针域”来保存
			
			//数据结点
			struct	BiTNode
			{
				ElemType data;
				//int num;//引用计数,具有data这个值的结点数量
				struct BiTNode *lchild,*rchild;
			};
			
4.使用链式存储结构建立一颗二叉树
	一般二叉树会建立成一颗二叉排序树(二叉查找树).
		二叉排序树(二叉查找树):
			二叉排序树或者是一颗空树,或者是具有以下性质的二叉树:
			a.若它的左子树不为空,则左子树上所有结点的值均小于它的根节点
			b.若它的右子树不为空,则右子树上所有结点的值均大于它的根节点
			c.它的左右子树也分别是一颗二叉排序树
			左 < 根 < 右
			
			明白为什么叫做二叉查找树了吗?(自带二分法)
			
	1. 如何创建一颗二叉排序树.
		字符串:FHGBDAC
		
5.如何遍历一颗二叉树
	二叉树的遍历和排不排序没有一毛钱关系。
	按照某一种方法,去访问二叉树中的每一个结点,使得每一个结点均会被访问一次,而且仅会被访问一次。“把二叉树线性化的过程”
			
		遍历分为以下几种:
			先序(先根)遍历  根  左  右
			中序(中根)遍历  左  根  右 
			后序(后根)遍历  左  右  根  
			以上三种遍历方式,都约定左子树的访问必须在右子树之前,根据根节点的不同顺序,得到上面三种遍历方式。

		一般的笔试题只有两种:
		1.从一棵树的形态,写出它的三种遍历方式。
			如果考虑排序性,使用FHGBDAC建立一颗二叉树,三种遍历方式为:
			
				先:FBADCHG
				中:ABCDFGH
				后:ACDBGHF
		
		2.根据二叉树的遍历序列,得到树的形态。
				先:EBADCFHGIKJ
				中:ABCDEFGHIJK
			
	先序遍历的方法:(递归)
		f(r) --->使用先序遍历的方法,遍历以r为根节点的二叉树
			if(r != NULL)
			{
				先访问根节点 print(r)
				按照先序遍历的方法访问r的左子树 f(r->lchild)
				按照先序遍历的方法访问r的右子树 f(r->rchild)
			}
		
		
		f(r) --->使用先序遍历的方法,遍历以r为根节点的二叉树
		{
			if(r==NULL)
			{
				return;
			}
			根 print(r->data)
			r的左子树 f(r->lchild)
			r的右子树 f(r->rchild)
		}	
			
	中序遍历的方法:
		m(r) -->使用中序遍历的方法,访问以r为根节点的二叉树
		{
			if(r == NULL)
			{
				return;
			}
			先按照中序遍历的方法访问r的左子树 m(r->lchild)
			访问根节点  print(r)
			再按照中序遍历的方法访问r的右子树 m(r->rchild)
		}
			
	后序遍历的方法:
		l(r) --->使用后序遍历的方法,访问以r为根节点的二叉树
		{
			if(r==NULL)
			{
				return;
			}
			使用后序遍历的方法访问r的左子树 l(r->lchild);
			使用后序遍历的方法访问r的右子树 l(r->rchild);
			根节点 print(r);
		}
	

6.排序二叉树中结点的删除
	删除元素不能破坏二叉树的排序性。
	/*
	delete_x:在t指向的二叉树中删除一个元素x
	返回值:返回删除后的二叉树的根节点指针
	*/
	BiTNode *delete_x(BiTNode *t,TElemType x)
	{
		a.找到要删除的结点 
		
		b.分情况删除操作
	}
	
	删除操作分两步进行
		a.找到要删除的结点 
			从根节点开始找,待删除的值大于根节点就往根节点的右子树中查找,否则就往根节点的左子树中查找,如果相等则表示找到了
			//px 指向要删除的结点
			//pr 指向要删除的结点的父节点
		
		b.分情况删除操作,假设要删除的结点为px,px的父节点为pr
			1.删除的结点是叶子结点(px的L和R都为NULL)
				if(px->lchild == NULL && px->rchild==NULL)
				{
					if(px == t)
					{
					}
				}
				判断px是pr的左孩子还是右孩子
				pr->l = NULL or pr->r = NULL;(考虑px是否为根节点)
				free(px);

			2.px只有一个孩子
				要删除的结点只有一个孩子(左/右)
				让它的孩子顶上去
				if(px->lchild == NULL) //只有一个右子,(考虑px是否为根节点)
				{
					
				}
				if(px->rchild == NULL) //只有一个左子,(考虑px是否为根节点)
				{
				
				}
				
			3.px的左子和右子都不为NULL
				一般的做法是在px的左子树或者右子树中找一个合适的结点继承px的宝座
				继承宝座的结点必须比px左子树中所有结点都大,比px右子树中所有结点都小
				一般有两个选择:
					在左子树中选最大的
						px-->左--->右....
					在右子树中选最小的
						px-->右--->左....
				
				记录要删除的结点的指针 pf = px;	
				px继续往后遍历,px指向替代结点指针

				把pf的值和px的值交换,再删除px
				
				删除px的时候,肯定px是属于前面两种中的一种(不可能px既有L又有R)
				
				goto 1;		
		自己把删除结点的函数写出来。		
	
		二叉排序树又叫做二叉查找树,因为有非常良好的查找性能。
		每一层只需要比较一个结点即可,按照理论,如果树建立的足够合理(尽量是一个完全二叉树),在100万个元素中找一个元素最多比较20次。
		但是可能存在一些极端的情况,在建立二叉排序树的时候,输入的数值如果是有序的,二叉树就会退化成“链表”
		极端的二叉排序树,不能体现“二分法”的优势,尽量不要增加二叉树的高度,而是把二叉树建立为完全二叉树
		
	普通的二叉排序树如果尽量称为完全二叉树呢?
		平衡算法(平衡二叉树)
		
7.平衡二叉树(Balanced Binary Tree)
	又称为AVL树.
	它或者是一颗空树,或者是具有以下性质的二叉树:
	它的左子树和右子树都是平衡二叉树,而且左子树和右子树的高度之差的绝对值不能超过1
	
	若将二叉树上每一个结点的平衡因子(Balanced Factor)定义为该节点左子树高度减去右子树高度,
	则平衡二叉树上所有结点的平衡因子只有可能是-1,0,1,只要二叉树上有一个结点的平衡因子绝对值大于1,则该二叉树就是不平衡的。
	
	重点:
		二叉排序树----->平衡的二叉排序树
		
		往一颗平衡二叉排序树中加入一个结点,使二叉排序树任然具有平衡性。
		
	平衡操作(算法):
		有四种情况
	(1).单向右旋平衡处理 SingleRotateWithRight	
		
		因为在不平衡结点的左子结点的左边新增一个结点导致不平衡的
		对不平衡结点进行“单向右旋平衡处理”
		
		k为不平衡结点
		k1位不平衡结点的左子结点
		对k进行单向右旋平衡处理
		
		k1 = k->lchild;
		k->lchild=k1->rchild;
		k1->rchild=k;
		//重新计算k和k1的高度
		return k1;//新的根节点
		
	(2).单向左旋平衡处理 SingleRotateWithLeft   右右为左
		因为在不平衡结点的右子结点的左右边新增一个结点导致不平衡的
		对不平衡结点进行“单向左旋平衡处理”
		
		k为不平衡结点
		k1为不平衡结点的右子结点
		在k1的右边新加入结点导致了不平衡

		k1 = k->rchild;
		k->rchild=k1->lchild;
		k1->lchild=k;

		return k1;
		k的右子结点称为新的根节点
		
		
	(3).双向旋转(先左后右)平衡处理	 DoubleRotateWithLeftRight
		
		在不平衡结点的左子结点的右边新增加了一个结点,导致不平衡的,
		对不平衡结点进行“双向旋转(先左后右)平衡处理”
		
		首先对不平衡结点的左子结点进行一个“单向左旋平衡处理”
		然后在对不平衡结点进行一个“单向右旋平衡处理”
		
		k为不平衡结点
		k1位不平衡结点的左子结点	k1 = k->lchild;
		x为新加入结点(x > k1->data && x < k->data)  x在k的左子结点的右边,导致k不平衡
		
		k1 = k->lchild;
		k->lchild = SingleRotateWithLeft(k1);
		return SingleRotateWithRight(k);
		
		
	(3).双向旋转(先右后左)平衡处理	 DoubleRotateWithRightLeft	
		在不平衡结点的右子结点的左边新增加了一个结点,导致不平衡的,
		对不平衡结点进行“双向旋转(先右后左)平衡处理”
		
		首先对不平衡结点的右子结点进行一个“单向右旋平衡处理”
		然后在对不平衡结点进行一个“单向左旋平衡处理”
		k1 = k->rchild;
		k->rchild = SingleRotateWithRight(k1);
		return SingleRotateWithLeft(k);
		
		
		自己实现AVL树

	
8.平衡二叉树结点的删除(Balanced Binary Tree)
	删除平衡二叉树中的结点使得二叉树任然具有平衡性
	暂时没有特别统一的算法.
	
	平衡二叉树结点的删除都是虚假删除
	在结点中增加一个引用计数(表明此结点在二叉树中的数量)
	如果删除一个结点,只需要把引用计数减一,但是实际上这个结点还存在.
	只是保留这个结点的关系维持二叉树的平衡性。
	
	当二叉树中大部分结点都被删除了,可以重构二叉树。
	
9.树和森林的表示方法
	“孩子兄弟表示法”
	可以利用这一种方法把多叉树和森林表示成一颗“二叉树”
	
	struct TNode
	{
		TElemType data; //数据域,保存用户的数据
		struct TNode *first_child;//保存第一个孩子的指针
		struct TNode *next_silbing;//保存下一个兄弟的指针
	
	};
	

	
		
作业:
	const有什么作用?
	1.自己写一个二叉树的创建
	2.写出二叉树的中序遍历和后序遍历代码(可以使用递归)
	3.写出二叉树的层次遍历代码。
		从左至右,从上至下,遍历每一个节点
		思路:
		利用队列
		约定访问一个结点后,让它入队列
		
		while(队列不为NULL)
		{
			出队列,
			访问出队元素的左子结点和右子结点
			访问完需要入队
		}
	4.写一个函数,能够计算二叉树的高度和宽度(在3的基础上就可以完成)
			h(r) 表示二叉树r的高度
				if(r == NULL)
				{
					return 0;
				}else
				{
					//左子树和右子树中高的那一个+1
				}
	

作业:
	自己把今天的代码写一遍
	1.写出先序遍历的非递归代码.
		利用栈实现。
	//2.写出中序遍历的非递归代码.(参考网络思路)
	//3.写出后序遍历的非递归代码.(参考网络思路)
	
	1.设计算法,判断一棵树是否为排序二叉树
	2.设计算法,判断一棵树是否为平衡二叉树
	2.设计算法,判断一棵树是否为完全二叉树
	2.设计算法,判断一棵树是否为满二叉树
	
	
	

